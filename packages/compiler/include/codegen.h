#pragma once
#include "types.h"
#include "opcodes.h"
#include <vector>
#include <array>

class CodeGenerator
{
public:
    /**
     * @brief Generates bytecode from the given AST.
     *
     * @param ast The root AST node representing the program.
     * @return The generated bytecode as a vector of bytes.
     *
     * @throws std::runtime_error if the program is invalid.
     */
    Bytes generate(ASTNodePtr ast);

private:
    /**
     * @brief Writes a 32-bit unsigned integer into the byte array at the specified offset.
     *
     * @param buffer The byte array to write into.
     * @param offset The offset within the array to write the integer.
     * @param value The 32-bit unsigned integer value to write.
     * @tparam N The size of the byte array.
     *
     * @throws std::runtime_error if the offset is out of bounds.
     */
    template<size_t N>
    void writeUint32(std::array<byte, N> &buffer, size_t offset, uint32_t value, bool bigEndian = false);

    /**
     * @brief Writes a 32-bit signed integer into the byte array at the specified offset.
     *
     * @param buffer The byte array to write into.
     * @param offset The offset within the array to write the integer.
     * @param value The 32-bit signed integer value to write.
     * @param N The size of the byte array.
     *
     * @throws std::runtime_error if the offset is out of bounds.
     */
    template<size_t N>
    void writeInt32(std::array<byte, N> &buffer, size_t offset, int32_t value);

    /**
     * @brief Writes a 32-bit float into the byte array at the specified offset.
     */
    template<size_t N>
    void writeFloat(std::array<byte, N> &buffer, size_t offset, float value);

    /**
     * @brief Outputs the bytecode for a single instruction (80-byte block).
     *
     * @param opcode The opcode of the instruction.
     * @param flag The special flag (true/false).
     * @param operands The operands for the instruction (64 bytes).
     * @return The generated instruction as a byte array.
     */
    Instruction createInstruction(Opcode opcode, bool flag, const Operands &operands);

    /**
     * @brief Encodes the opcode from a function name.
     *
     * @param functionName The name of the function to encode.
     * @return The corresponding Opcode enum value
     *
     * @throws std::runtime_error if the function name is not recognized.
     */
    Opcode encodeOpcode(const std::string &functionName);

    /**
     * @brief Encodes the operands from a list of AST node pointers.
     *
     * @param arguments The list of AST node pointers representing the arguments.
     * @return The encoded operands as a 64-byte array.
     *
     * @throws std::runtime_error if any argument is invalid.
     *
     * @note Takes a vector of raw ASTNode* pointers to avoid copying unique_ptrs.
     */
    Operands encodeOperands(const std::vector<ASTNode *> &arguments);

    /**
     * @brief Generates the bytecode for single function call instruction represented by a ListNode.
     *
     * @param functionCall The ListNode representing the function call.
     * @return The generated bytecode as a vector of bytes.
     *
     * @throws std::runtime_error if the function call is invalid.
     */
    Bytes generateInstruction(ListNode *functionCall);

    /**
     * @brief Generates the operands byte array for a specific opcode.
     *
     * @param opcode The opcode for which to generate operands.
     * @param elements The list of AST node pointers representing the arguments.
     * @param functionName The name of the function (for error messages).
     * @return The generated operands as a 64-byte array.
     *
     * @throws std::runtime_error if `ensureArgumentCount` fails.
     *
     * @note Takes a vector of raw ASTNode* pointers to avoid copying unique_ptrs.
     */
    Operands generateOperandsForOpcode(Opcode opcode, const std::vector<ASTNodePtr> &elements, const std::string &functionName);

    /**
     * @brief Ensures that the number of arguments matches the expected count.
     *
     * @param elements The list of AST node pointers representing the arguments.
     * @param expectedCount The expected number of arguments.
     * @param functionName The name of the function (for error messages).
     *
     * @throws std::runtime_error if the argument count does not match.
     */
    void ensureArgumentCount(const std::vector<ASTNodePtr> &elements, size_t expectedCount, const std::string &functionName);

    /**
     * @brief Extracts an integer argument from the AST node list at the specified index.
     *
     * @param elements The list of AST node pointers representing the arguments.
     * @param index The index of the argument to extract.
     * @param functionName The name of the function (for error messages).
     * @param paramName The name of the parameter (for error messages).
     *
     * @return The extracted integer value.
     */
    int getIntegerArgument(const std::vector<ASTNodePtr> &elements, size_t index, const std::string &functionName, const std::string &argName);

    /**
     * @brief Extracts a float argument from the AST node list at the specified index.
     *
     * @param elements The list of AST node pointers representing the arguments.
     * @param index The index of the argument to extract.
     * @param functionName The name of the function (for error messages).
     * @param paramName The name of the parameter (for error messages).
     *
     * @return The extracted float value.
     */
    float getFloatArgument(const std::vector<ASTNodePtr> &elements, size_t index, const std::string &functionName, const std::string &argName);
};
